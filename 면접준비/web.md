### 💜 브라우저에서 URL치면 발생하는 일
- 사용자가 브라우저에 URL을 입력
- 브라우저는 DNS(Domain Name System)을 통해 서버의 진짜 주소(IP)를 찾음
- TCP/IP 연결을 통해 HTTP요청이 서버로 전송 됨
- 서버는 HTTP 프로토콜을 활용해 HTTP 응답 메시지 생성
- TCP/IP 연결을 통해 요청한 컴퓨터로 전송
- 도착한 HTTP 응답 메시지는 웹페이지 데이터로 변환, 웹 브라우저에 의해 출력
- 
#### 🎈 IP(Internet Protocol)
- 출발지 IP, 도착지 IP 등으로 IP패킷을 만들고 데이터를 넣어 전송
- 인터넷(노드)를 거쳐 목적지IP(서버)에 도착
- 비연결성: 패킷을 받을 대상이 없거나, 서비스 불능 상태여도 패킷 전송
- 비신뢰성: 패킷소실, 패킷 전달 순서 문제 발생

#### 🎈 TCP(Transmission Control Protocol)
- 출발지 Port, 도착지 Port, 전송제어, 순서, 검증 정보 등을 넣은 TCP 세그먼트를 IP 패킷 안에 넣어 전송
- 연결지향(3way handshake): `syn` -> `syn+ack` -> `ack` (연결확인) 후 메시지 전송
- 데이터 전달 보증, 전송 순서 보장
- (참고) UDP: 비연결형. IP와 거의 같으나 Port, 체크섬 정도 추가되어있음. TCP보다 빠름.





### 💜 OSI 7계층
<img stc="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FS9lc1%2Fbtr5pyxTjZ6%2FXM5NxJPjqHymq1M0I8ikpK%2Fimg.png">

| OSI                                  | TCP/IP               | 기능                                        |
| ------------------------------------ | -------------------- | ------------------------------------------- |
| 응용계층<br/>표현 계층<br/>세션 계층 | 응용 계층            | ***HTTP, FTP, IRC, SSH, DNS*** <br/>SSL, FTP, IMAP, SSH<br/>VARIOUS API;S, SOCKETS         |
| 전송 계층                            | 전송 계층            | ***TCP, UDP*** ECN, SCTP, DCCP                              |
| 네트워크 계층                        | 인터넷 계층          | IP, IPSec, ICMP, IGMP, ARP, RARP                   |
| 데이터 링크 계층<br/>물리 계층       | 네트워크 액세스 계층 | Ethernet, SLIP, PPP, FDDI, HDLC<br/>Coax, Fiber, Wireless |

- 7 계층(응용 계층): 사용자와 직접 상호작용하는 응용 프로그램들이 포함된 계층
- 6 계층(표현 계층): 데이터의 형식(Format)을 정의하는 계층
- 5 계층(세션 계층): 컴퓨터끼리 통신을 하기 위해 TCP/IP 세션을 만들고 없애는 계층
- 4 계층(전송 계층): TCP와 UDP 프로토콜을 통해 통신을 활성화. 최종 수신 프로세스로 데이터의 전송을 담당하는 계층
- 3 계층(네트워크 계층): 패킷을 목적지까지 가장 빠른 길로 전송하기 위한 계층
- 2 계층(데이터링크 계층): 물리 계층으로 송수신되는 정보를 관리하여 안전하게 전달되도록 도와주는 역할
- 1 계층(물리 계층): 데이터를 전기 신호로 바꾸어주는 계층

### 💜 URI, URL, URN
- URI(Uniform Resource Identifier) : 리소스 식별
- URL(...Location) : 위치를 식별
- URN(...Name) : 이름을 식별, 보편화되지 않음

### 💜 HTTP 메서드
#### 🎈 메서드 종류
- Get: 요청에 Body가 없음. Url에 데이터 노출
- Post: 요청에 Body 있음. 새 리소스 생성(등록). 요청 데이터 처리
- Put: 리소스 완전히 대체. 리소스가 없으면 생성
- Patch: 리소스 부분 변경
- Delete

#### 🎈 메서드 속성
- 안전: 호출해도 리소스를 변경하지 않는다(Get)
- 멱등: 몇번을 호출해도 결과가 똑같다(Get, Put, Delete)
- 캐시가능: 응답 결과 리소스를 캐시해서 사용 (Get)

### 💜 HTTP 응답코드
- 200 : Successful
- 300 : Redirect
  - 리다이렉트 시 get(본문 제거될 수 있음)
  - 301: 영구 리다이렉션. 요청한 정보가 새로운 주소로 영구 옮겨감
  - 302: 일시 리다이렉션. 이전 페이지에 대한 정보 가지고 있을 수 있음.
- 400 : Client Error
  - 400 Bad Request : 요청 파라미터가 잘못 되었을때
  - 401 Unauthorized: 인증 필요
  - 403 Forbidden: 접근권한(인가) 불충분
  - 404 Not Found
- 500 : Server Error

### 💜 쿠키, 세션, 캐시
#### 🎈 쿠키란?
- HTTP에서 클라이언트의 상태정보를 `클라이언트의 PC`에 저장했다가, 필요시 참조 또는 재사용
- 이름, 값, 만료일, 경로 정보로 구성되어 있음
- 동작방식
  - 클라이언트가 페이지 요청
  - 웹서버가 쿠키 생성 후, 쿠키에 정보 담아 클라이언트에게 반환
  - 클라이언트가 쿠키 저장하고 있다가, 서버에 요청할 때 쿠키를 전송
- 사용 예시
  - 아이디, 비번 저장여부
  - 오늘 이 창을 다시 보지 않기

#### 🎈 세션이란?
- 일정시간동안 같은 사용자로부터 들어오는 요구를 `하나의 상태`로 보고 상태를 유지시킴.
  - 일정시간: 사용자가 웹 브라우저를 통해 웹서버에 접속한 시점부터 웹 브라우저를 종료 하여 연결을 끝내는 시간
- 웹컨테이너의 상태를 유지하기 위한 정보를 `웹 서버`에 저장 (세션쿠키)
- 각 클라이언트에 고유 sessionId 부여
- 저장 데이터에 제한이 없음 (서버 용량 허용 한도 내)
- 동작방식
  - 클라이언트가 페이지 요청
  - 서버는 클라이언트의 Request-Header의 Cookie 확인해서 sessionId 없으면 sessionId 생성하고 돌려줌
  - 서버는 Cookie를 사용해 sessionId를 서버에 저장
  - 클라이언트 재접속 시, 쿠키를 이용해 sessionId값을 서버에 전달
- 사용 예시
  - 은행 어플 사용 시 로그인 시간 유지

#### 🎈 쿠키와 세션의 차이
- 쿠키는 사용자의 pc에 저장, 세션은 서버에 저장
- 쿠키보다 세션이 보안 면에서 우수
  - 세션은 쿠키를 이용하여 sessionId만 저장, 서버에서 처리
  - 쿠키는 로컬에 저장되므로 변질 되거나, 요청을 보낼때 스피닝 당할 우려가 있음.
  - 세션은 브라우저가 종료되면 만료기간에 상관없이 삭제. 쿠키는 파일로 저장되기때문에 브라우저 종료 되어도 정보 유지.
- 속도는 쿠키가 세션보다 빠름

#### 🎈 캐시란?
- 리소스 파일들의 임시 저장소
- 한번 전송받은 데이터를 임시로 저장(복사) 해놨다가 다시 사용
- 반복적으로 사용하는 콘텐츠를 빠르게 이용할 수 있고, 데이터 사용량도 줄일 수 있음.
- 쿠키와 비슷하지만 쿠키/세션은 사용자 인증을 돕는데 목적
- 캐시는 데이터 전송량을 줄이고 서비스 이용 속도를 높이는데 목적

### 💜 토큰 기반 인증 
#### 🎈 JWT
- jason web token
#### 🎈 OAuth

### 💜 CORS란?
CORS 해결방법

### 💜 REST, REST API, RESTful 이란?
REST API 장점, 단점

### 💜 HTTPS
- HTTP: 인터넷 상에서 정보를 주고 받기 위한 프로토콜
- HTTP에 암호화(SSL)가 추가 된 프로토콜
- SSL: 클라이언트와 서버간의 통신을 제3자(CA) 업체가 보증해주는 전자화 된 문서
  - 서비스의 정보(CA, 서비스의 도메인 등), 서버측 공개키(공개키의 내용, 공개키 암호화 방법) 포함
  
#### 🎈 SSL 동작방식 [참고자료: 생활코딩](https://opentutorials.org/course/228/4894)
- 클라이언트가 서버로 최초 연결을 시도함
- 서버는 `공개키`를 클라이언트에게 전달
- 클라이언트는 대칭키를 공개키로 암호화하고 서버로 암호화 된 `대칭키` 전송
- 서버는 자신의 비밀키로 `대칭키` 복호화
- 서버와 클라이언트간 대칭키 암호화 방식 통신
- 세션 종료 시 대칭키 폐기

#### 🎈 공개키 방식
- 공개키와 비밀키 두개를 가짐
- 공개키로 암호화 하면 비밀키로 복호화, 비밀키로 암호화 하면 공개키로 복호화
- 비밀키를 자신이 가지고, 공개키는 타인에게 제공
- 공개키를 제공받은 사람은 공개키를 이용해서 정보를 암호화 후 비밀키 소유자에게 정보 전송
- 비밀키 소유자는 이 키를 이용하여 암호화 된 정보 복호화
- 공개키가 유출되어도 비밀키를 모르면 정보를 복호화 할 수 없음

#### 🎈 대칭키 방식
- 암호화할 때의 키와 복호화 할때의 키가 같음.
- 대칭키가 유출되면 키를 획득한 공격자는 암호의 내용을 복호화 할 수 있기 때문에 위험

### 💜 로드밸런싱

### 💜 JSON, XML의 차이

### 💜 MIME이란?

### 💜 AWS란?
  
#### 🎈 참조블로그
- [beeguri](https://github.com/beeguriri/Selfstudy_Springboot/wiki/%EB%AA%A8%EB%93%A0-%EA%B0%9C%EB%B0%9C%EC%9E%90%EB%A5%BC-%EC%9C%84%ED%95%9C-HTTP-%EC%9B%B9-%EA%B8%B0%EB%B3%B8-%EC%A7%80%EC%8B%9D)
- [개발자 장고](https://youtu.be/227BmVM2yY0)
- [Lea Hwang](https://lealea.tistory.com/236)
