### 💜 자바 애플리케이션, JVM 실행 과정
<img src="http://www.tcpschool.com/lectures/img_java_programming.png">

- [출처: 코딩의 시작, TCP School](http://www.tcpschool.com/java/java_intro_programming#:~:text=%EC%9E%90%EB%B0%94%20%EB%B0%94%EC%9D%B4%ED%8A%B8%20%EC%BD%94%EB%93%9C(Java%20bytecode)%EB%9E%80%20%EC%9E%90%EB%B0%94%20%EA%B0%80%EC%83%81%20%EB%A8%B8%EC%8B%A0%EC%9D%B4,class%EC%9E%85%EB%8B%88%EB%8B%A4.)
- 컴파일러가 자바 소스를 바이트 코드로 변환 (*.java -> *.class)
    - 자바 가상 머신(JVM)만 설치되어 있으면 자바 바이트 코드는 어떤 운영체제에서라도 실행될 수 있음
    - JVM은 운영체제에 종속적, 각 운영체제에 맞는 자바 가상 머신을 설치해야 함.
    - 자바 프로그램은 JVM 한 단계를 더 거쳐야 하므로, 상대적으로 실행 속도가 느림
- Class Loader가 바이트 코드를 런타임 데이터 영역에 로드
- JIT 컴파일러가 바이트 코드를 바로 기계어로 변환
- 프로그램 실행
- 가비지 컬렉터를 이용하여 사용하지 않는 메모리 자동으로 회수

### 💜 자바 메모리 구조
- 메서드 영역 (공통) : 클래스 별 전역변수, 정적 변수, 메서드 정보 저장
- 스택 영역(스레드별) : 호츨 된 메서드의 매개변수, 지역변수, 리턴정보 등  저장
- 힙 영역(공통) : 런타임 중 생성되는 객체들이 동적으로 할당

### 💜 가비지 컬렉션이란?
- JVM에서 메모리를 관리해주는 모듈
- Heap 메모리를 재활용 하기 위하여 더이상 참조되지 않는 객체를 메모리에서 제거
- 개발자가 직접 메모리를 정리하지 않아도 되서 개발 속도가 향상되는 장점
- 참조되지 않는 객체를 찾는 과정에서 스레드가 잠시 중단되어 성능이 떨어지는 단점

### 💜 객체지향프로그래밍이란?
- 객체에서 필요한 특징(필드, 메서드)을 뽑아 프로그래밍 수행
#### 🎈 객체지향 프로그래밍 4가지 특징
- 추상화 : 공통적인 특징을 뽑아 개념화
- 캡슐화 : 객체들 내부에 숨겨야되는 정보는 숨김. 내부 높은 응집도, 외부 낮은 결합도
- 상속성 : 기존의 클래스에 기능을 추가하거나 재정의하여 새로운 클래스를 정의
- 다형성 : 같은 메서드에 매개 변수를 다르게 주어 사용할 수 있음

#### 🎈 추상 클래스와 인터페이스의 차이
- 추상클래스
    - `abstract` 지시자, 추상메서드가 하나 이상 포함
    - 상속을 받아 부모 클래스 기능을 재사용, 확장 하기 위함
- 인터페이스
    - `interface` 지시자, 모든 메서드가 추상 메서드로 정의
    - 함수 구현을 강제해서 객체들은 모두 같은 동작을 할 수 있음을 보장
      
#### 🎈 객체지향 설계 5대 원칙 : SOLID
- SRP : 단일 책임 원칙 (Single Responsibility Principle)
    - 한 클래스는 하나의 책임만 가져야 한다.
    - `변경`이 있을 때 파급 효과가 적으면 단일 책임 원칙을 잘 따른 것
- OCP : 개방-폐쇄 원칙 (Open/Closed Principle)
    - 확장에는 열려있으나 변경에는 닫혀 있어야 한다.
    - 인터페이스를 구현한 새로운 클래스를 만들어서 새로운 기능 구현 (다형성 활용)
- LSP : 리스코프 치환 원칙 (Liskov Substitution Principle)
    - 구현클래스는 인터페이스 규칙을 다 지켜야 함
- ISP : 인터페이스 분리 원칙(Interface Segregation Principle)
    - 기능 별 인터페이스 분리 (특정 클라이언트를 위한 여러개의 인터페이스로 분리)
- DIP : 의존관계 역전 원칙(Dependency Inversion Principle)
    - 구현 클래스에 의존하지 말고 (구체화 의존x)
    - 인터페이스에 의존(추상화 의존o)
      
#### 🎈 오버로딩 오버라이딩
- 오버로딩
    - 같은 이름의 메소드를 중복하여 정의, 매개변수의 개수나 타입을 다르게 함.
    - 메소드 호출 시 매개변수의 타입이나 개수에 대해 크게 신경을 쓰지 않고 호출할 수 있게 됨
    - 다형성(polymorphism)을 구현하는 방법 중 하나
- 오버라이딩
    - 상속받은 부모 클래스의 메소드를 재정의하여 사용
    - 메서드의 동작만 재정의 하는 것이므로, 매개변수의 개수나 타입은 같아야 함.

### 💜 정적변수와 전역변수의 차이
- 전역변수 : 프로그램 종료 시 해제, 다른 파일에서도 해당 변수에 접근 가능
- 정적변수 : 프로그램 종료 시 해제, 해당 파일내에서만 접근 가능, 새로 객체를 만들지 않고 이미 선언된 객체를 사용할 수 있음
- 지역변수 : {} 메모리에서 해제, 사용자가 직접 초기화
- java8 이후에서는 gc가 정적변수도 관리한다고 함..

### 💜 접근제어자
- 정보 은닉을 위해 접근 제어자 사용 (캡슐화)
- private : 외부에서 접근 불가, public method 이용해서만 접근할 수 있음 (setter, getter)
- public : 다른 패키지에서도 접근 가능
- defualt : 같은 패키지에서만 접근 가능, 별도 명시 하지 않고 사용
- protected : 같은패키지 접근 가능, 다른패키지에 속하는 자식클래스는 접근 가능

### 💜 final
- 변경 불가
- 필드, 지역변수에 사용하면 상수(constant)
- 메서드에 사용하면 오버라이딩 불가
- 클래스에 사용하면 상속 불가

### 💜 Wrapper Class
- 기본타입의 데이터(int, long, double, char, boolean, ..) 를 객체로 포장 해주는 클래스
    - 기본타입 : stack에 저장, 참조타입 : heap에 저장
- Boxing : 기본타입 -> Wrapper 클래스의 인스턴스 변환
- UnBoxing : Wrapper 클래스의 인스턴스에 저장된 값 -> 기본타입
- Wrapper Class는 비교 연산자(==)를 사용하면 인스턴스의 주소값을 비교 함
    -  값을 비교하려면 equals() 메서드 사용
- Wrapper Class는 불변 객체. 할당 된 값이 변하지 않음.
    -  수정 시 => 새로운 객체를 생성해서 반환
#### 🎈 String은 래퍼클래스인데 == 비교시 값 같게 나오는 이유
- String은 참조형 데이터 타입이지만, heap 영역 내부에 별도의 `String Context Pool` 영역을 가짐
- 새로운 String 선언 시 `String Context Pool` 영역에 값이 존재하면 새로운 객체를 만들지 않고 해당 객체의 주소값 할당
    - 단, new 연산자로 새로운 객체 생성 시 비교 연산자 사용하면 `false`

### 💜 제네릭이란?
- 클래스나 메소드에서 사용할 내부 데이터 타입을 컴파일 시에 미리 지정
- 타입변수에는 기본타입 사용 불가, Wrapper Class 사용해야 함
- 클래스나 메소드 내부에서 사용되는 객체의 타입 안정성을 높일 수 있음
  
### 💜 자바 버전
- Java8 이후
- Optional
- Lambda
- Stream
- LocalDate

### 💜 컬렉션 프레임워크
- 자료구조(저장)와 알고리즘(처리)를 구조화 하여 구현
- List : 저장순서 유지, 중복저장 허용
- Set : 저장순서 유지 X, 중복저장 허용 X
    - HashSet : 저장순서 유지 X, 중복저장 허용 X, 객체 저장 시 equals() 메서드 오버라이딩
    - LinkedHashSet : 저장순서 유지 O, 중복저장 허용 X
    - TreeSet : 저장순서 유지 X, 중복저장 허용 X, 정렬 된 상태로 저장 (이진검색트리)
- Map : Key, Value로 구성, 저장순서 유지 X, key 중복 허용 X, Value 중복 허용
    - TreeMap : key 값 기준 정렬 된 상태로 저장 (이진검색트리)
- Stack : 클래스로 구현되어 있음 (push, pop, peek, ...)
- Queue : 인터페이스로 구현되어 있음 (offer, poll, peek, ...), 주로 LinkedList로 구현
