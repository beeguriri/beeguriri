### 💜 버블정렬
- 정렬하고자하는 배열 안에서 정렬이 일어나므로 메모리 공간 추가로 필요하지 않음
- 제자리정렬, 안정정렬
- 평균 O(n2)
- 구현방법
  - 1회전: 1 ~ n번째 원소까지 비교
    - 1,2번원소 비교에서 swap,
    - 2,3번 원소 비교해서 swap
    - ...
    - n-1,n번 원소 swap
    - 최대값이 맨 뒤로 이동
  - 2회전: 1~ n-1원소까지 비교
  - ...


### 💜 선택정렬
- 정렬하고자하는 배열 안에서 정렬이 일어나므로 메모리 공간 추가로 필요하지 않음
- 많은 교환이 일어나야할때 효울적
- 제자리정렬, 불안정정렬
- 평균 O(n2)
- 구현방법
  - 1회전: 1 ~ n중 최소값을 찾아 그 값을 제일 첫 원소와 교체
  - 2회전: 2 ~ n중 최소값을 찾아 그 값을 두번째 원소와 교체
  - ...

### 💜 삽입정렬 : 선택정렬과 유사, 2번째부터 탐색
- 정렬하고자하는 배열 안에서 정렬이 일어나므로 메모리 공간 추가로 필요하지 않음
- 대부분의 원소가 정렬되어있을경우 빠름
- 제자리정렬, 안정정렬
- 구현방법
  - 현재 타겟이 되는 숫자와 이전 위치에 있는 원소들을 비교
  - (첫 번째 타겟은 두 번째 원소부터 시작)
  - 타겟이 되는 숫자가 이전 위치에 있던 원소보다 작다면 위치를 서로 교환
  - 그 다음 타겟을 찾아 위와 같은 방법으로 반복한다. 
```java
for(int i = 1; i < size; i++) {
  int target = a[i];
	int j = i-1;
			
	// 타겟이 이전 원소보다 크기 전 까지 반복
	while(j>=0 && target<a[j]) {
				a[j+1] = a[j];	// 이전 원소를 한 칸씩 뒤로 미룬다.
				j--;
  }
			
  /*
   * 위 반복문에서 탈출 하는 경우 앞의 원소가 타겟보다 작다는 의미이므로
   * 타겟 원소는 j번째 원소 뒤에 와야한다.
   * 그러므로 타겟은 j + 1 에 위치하게 된다.
   */
  a[j + 1] = target;	
}
```

### 💜 퀵정렬 : 분할&정복
- 자바 arrays.sort() 방법
- 피벗을 기준으로 작은값은 왼쪽 큰값은 오른쪽으로 배치
- 각 나눈 배열을 재귀로 다시 정렬
- 정렬하고자하는 배열 안에서 정렬이 일어나므로 메모리 공간 추가로 필요하지 않음
- O(nlogn)
- 정렬된 배열에서는 오히려 시간이 더 걸림

### 💜 병합정렬
- 정렬할 배열을 두개로 쪼개어 나가며 각 리스트 내에서 정렬 후 합병
- 링크드리스트 정렬시 효율적

#### 🎈 퀵정렬 vs 병합정렬
퀵정렬: 피봇을 기준으로 정렬 -> 배열 분할
병합정렬: 나눌수 잇을만큼 분할 후 합치면서 정렬

### 💜 힙정렬: 완전 이진트리
- 내림차순: 최대힙
- 오름차순: 최소힙
- 인덱스 순서로 노드 제일 마지막에 추가 후 부모노드와 비교하며 값을 swap
- O(nlogn)

#### 🎈 안정정렬 vs 불안정정렬
- 안정정렬 : 중복부분 입력 순서 유지
  - 예: 버블정렬, 삽입정렬, 병합정렬
- 불안정정렬 : 중복부분 입력 순서 유지 안함
  - 예: 선택정렬, 퀵정렬
